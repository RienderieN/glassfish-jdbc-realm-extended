package glassfish.security.auth.jdbc.util;

import glassfish.security.auth.jdbc.util.dao.SecurityStorage;
import glassfish.security.auth.jdbc.util.dao.exceptions.SecurityStorageException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;
import javax.sql.DataSource;
import org.hsqldb.jdbc.JDBCDataSource;
import org.junit.Assert;
import org.junit.BeforeClass;
import org.junit.Test;
import org.osjava.sj.memory.MemoryContextFactory;

/*
 * SecurityStorage class test with a datasource composed by 2 tables,
 * one called USERS (ID, USERNAME, PASSWORD) and an other GROUPS(ID,NAME,USERNAME).
 * GROUPS USERNAME column describes a user name which already exists into
 * USERS table. (Basic case glassfish).
 */
public class SecurityStorageTest
{

    public static final String[][] USERS = {
        { "SuperMan", "SuperManPass" },
        { "SuperMario", "SuperMarioPass" },
        { "Lutor", "LutorPass" },
        { "Bowser", "BowserPass" }
    };
    public static final String[] GROUPS = {
        "GOOD_GUY", "BAD_GUY"
    };

    public static final String DATASOURCE_JNDI = "java:/comp/env/jdbc/datasourceTest";

    @BeforeClass
    public static void init()
    {
        createContext();
        createDataSource();
        insertData();
    }

    public static void createContext()
    {
        try {
            System.setProperty( Context.INITIAL_CONTEXT_FACTORY, MemoryContextFactory.class.getName() );
            System.setProperty( "org.osjava.sj.jndi.shared", "true" );
            InitialContext ic = new InitialContext();
            ic.createSubcontext( "java:/comp/env/jdbc" );

            JDBCDataSource ds = new JDBCDataSource();
            ds.setDatabase( "jdbc:hsqldb:mem:test" );
            ds.setUser( "SA" );
            ds.setPassword( "" );
            ic.bind( DATASOURCE_JNDI, ds );
        } catch ( NamingException ex ) {
            Logger.getLogger( SecurityStorageTest.class.getName() ).severe( "Oups !!! There is an error into the createContext function" );
            ex.printStackTrace();
        }
    }

    public static void createDataSource()
    {
        Connection conn = null;
        try {
            InitialContext ctx = new InitialContext();
            DataSource ds = ( DataSource ) ctx.lookup( DATASOURCE_JNDI );
            conn = ds.getConnection();
            conn.prepareStatement( "CREATE TABLE USERS( "
                    + "ID INT GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY,"
                    + " USERNAME VARCHAR(50) NOT NULL,"
                    + " PASSWORD VARCHAR(128) NOT NULL"
                    + ")" ).executeUpdate();
            conn.prepareStatement( "CREATE TABLE GROUPS( "
                    + "ID INT GENERATED BY DEFAULT AS IDENTITY(START WITH 1) PRIMARY KEY,"
                    + " NAME VARCHAR(20) NOT NULL,"
                    + " USERNAME VARCHAR(50) NOT NULL"
                    + ")" ).executeUpdate();
        } catch ( SQLException | NamingException ex ) {
            Logger.getLogger( SecurityStorageTest.class.getName() ).log( Level.SEVERE,
                    "Oups !! There is an error into the createDataSource function", ex );
            ex.printStackTrace();
        } finally {
            close( conn, null, null );
        }
    }

    public static void insertData()
    {
        Connection conn = null;
        PreparedStatement stmt = null;

        try {
            InitialContext ctx = new InitialContext();
            DataSource ds = ( DataSource ) ctx.lookup( DATASOURCE_JNDI );
            conn = ds.getConnection();
            // INSERT USERS
            stmt = conn.prepareStatement( "INSERT INTO USERS(USERNAME,PASSWORD) VALUES(?,?)" );
            for ( String[] user : USERS ) {
                stmt.setString( 1, user[0] );
                stmt.setString( 2, user[1] );
                stmt.executeUpdate();
            }

            // INSERT GROUPS GOOD GUY
            stmt = conn.prepareStatement( "INSERT INTO GROUPS(NAME, USERNAME) VALUES(?,?)" );
            stmt.setString( 1, GROUPS[0] );
            stmt.setString( 2, USERS[0][0] );
            stmt.executeUpdate();
            stmt.clearParameters();
            stmt.setString( 1, GROUPS[0] );
            stmt.setString( 2, USERS[1][0] );
            stmt.executeUpdate();

            // INSERT GROUPS BAD GUY
            stmt.clearParameters();
            stmt.setString( 1, GROUPS[1] );
            stmt.setString( 2, USERS[2][0] );
            stmt.executeUpdate();
            stmt.clearParameters();
            stmt.setString( 1, GROUPS[1] );
            stmt.setString( 2, USERS[3][0] );
            stmt.executeUpdate();

            // ADD Bowser user into GOOD GUY group
            stmt.clearParameters();
            stmt.setString( 1, GROUPS[0] );
            stmt.setString( 2, USERS[3][0] );
            stmt.executeUpdate();

        } catch ( NamingException | SQLException ex ) {
            Logger.getLogger( SecurityStorageTest.class.getName() ).log( Level.SEVERE, "Oups !! There is an error into the insertData function", ex );
        } finally {
            close( conn, stmt, null );
        }
    }

    public static void close( Connection conn, PreparedStatement stmt, ResultSet res )
    {
        try {
            if ( res != null && !res.isClosed() ) {
                res.close();
            }
        } catch ( SQLException ex ) {
            Logger.getLogger( SecurityStorageTest.class.getName() ).log( Level.SEVERE, "Cannot close ResultSet", ex );
        }

        try {
            if ( stmt != null && !stmt.isClosed() ) {
                stmt.close();
            }
        } catch ( SQLException ex ) {
            Logger.getLogger( SecurityStorageTest.class.getName() ).log( Level.SEVERE, "Cannot close PreparedStatement", ex );
        }

        try {
            if ( conn != null && conn.isClosed() ) {
                conn.close();
            }
        } catch ( SQLException ex ) {
            Logger.getLogger( SecurityStorageTest.class.getName() ).log( Level.SEVERE, "Cannot close Connection", ex );
        }
    }

    /*
     * Should throw a SecurityStorageException because the Properties Object
     * gave as argument to the SecurityStorage constructor cannot be null.
     *
     */
    @Test( expected = SecurityStorageException.class )
    public void should_throw_SecurityStorageException_properties_null()
            throws SecurityStorageException
    {
        Properties props = null;
        SecurityStorage secs = new SecurityStorage( props );
    }

    /*
     * Should throw a SecurityStorageException because a mandatory property is missing,
     * in this case, it's the group table name.
     */
    @Test( expected = SecurityStorageException.class )
    public void should_throw_SecurityStorageException_mandatory_property_groupTable_name()
            throws SecurityStorageException
    {
        Properties props = new Properties();
        props.setProperty( SecurityStorage.PROPERTY.DATASOURCE_JNDI.toString(), DATASOURCE_JNDI );
        props.setProperty( SecurityStorage.PROPERTY.USER_TABLE.toString(), "USERS" );
        props.setProperty( SecurityStorage.PROPERTY.USER_NAME_COLUMN.toString(), "USERNAME" );
        props.setProperty( SecurityStorage.PROPERTY.USER_PASSWORD_COLUMN.toString(), "PASSWORD" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_NAME_COLUMN.toString(), "NAME" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_USER_NAME_COLUMN.toString(), "USERNAME" );

        SecurityStorage secs = new SecurityStorage( props );

    }

    @Test
    public void should_create_SecurityStorage_instance()
            throws SecurityStorageException
    {
        Properties props = new Properties();
        props.setProperty( SecurityStorage.PROPERTY.DATASOURCE_JNDI.toString(), DATASOURCE_JNDI );
        props.setProperty( SecurityStorage.PROPERTY.USER_TABLE.toString(), "USERS" );
        props.setProperty( SecurityStorage.PROPERTY.USER_NAME_COLUMN.toString(), "USERNAME" );
        props.setProperty( SecurityStorage.PROPERTY.USER_PASSWORD_COLUMN.toString(), "PASSWORD" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_TABLE.toString(), "GROUPS" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_NAME_COLUMN.toString(), "NAME" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_USER_NAME_COLUMN.toString(), "USERNAME" );
        SecurityStorage secs = new SecurityStorage( props );
        Assert.assertNotNull( "Should create a SecurityStorage instance", secs );
    }

    @Test
    public void should_findPassword_user()
            throws SecurityStorageException
    {
        String[] superMan = USERS[0];
        Properties props = new Properties();
        props.setProperty( SecurityStorage.PROPERTY.DATASOURCE_JNDI.toString(), DATASOURCE_JNDI );
        props.setProperty( SecurityStorage.PROPERTY.USER_TABLE.toString(), "USERS" );
        props.setProperty( SecurityStorage.PROPERTY.USER_NAME_COLUMN.toString(), "USERNAME" );
        props.setProperty( SecurityStorage.PROPERTY.USER_PASSWORD_COLUMN.toString(), "PASSWORD" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_TABLE.toString(), "GROUPS" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_NAME_COLUMN.toString(), "NAME" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_USER_NAME_COLUMN.toString(), "USERNAME" );
        SecurityStorage secs = new SecurityStorage( props );
        Assert.assertEquals( "Should find the superMan user password", superMan[1], secs.findPassword( superMan[0] ) );
    }

    @Test
    public void should_findGroupNames_user()
            throws SecurityStorageException
    {
        String[] bowser = USERS[3];
        List<String> groupsToFind = Arrays.asList( GROUPS );
        List<String> groups;
        Properties props = new Properties();
        props.setProperty( SecurityStorage.PROPERTY.DATASOURCE_JNDI.toString(), DATASOURCE_JNDI );
        props.setProperty( SecurityStorage.PROPERTY.USER_TABLE.toString(), "USERS" );
        props.setProperty( SecurityStorage.PROPERTY.USER_NAME_COLUMN.toString(), "USERNAME" );
        props.setProperty( SecurityStorage.PROPERTY.USER_PASSWORD_COLUMN.toString(), "PASSWORD" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_TABLE.toString(), "GROUPS" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_NAME_COLUMN.toString(), "NAME" );
        props.setProperty( SecurityStorage.PROPERTY.GROUP_USER_NAME_COLUMN.toString(), "USERNAME" );

        SecurityStorage secs = new SecurityStorage( props );
        groups = Arrays.asList( secs.findGroupNames( bowser[0] ) );

        Assert.assertTrue( "Should find the Bowser user group names list", groupsToFind.containsAll( groups ) );
    }

}
